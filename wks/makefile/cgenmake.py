#!/usr/bin/env python
#coding=utf-8

import os,sys

def _get_allsrcs(root, ret):
    '''
    获取所有原代码文件，并将路径放入列表中
    root 源码存放的根路径
    ret 用于存放返回值的路径列表
    '''
    if os.path.isfile(root):
        if root.lower().endswith('.cpp') or root.lower().endswith('.c'):
            ret.append(root)
        return
    else:
        for e in os.listdir(root):
            _get_allsrcs(os.path.join(root, e), ret)

def _map_src_to_obj(src, obj_root, ret):
    '''
    源文件对应的目标文件
    obj_root 存放obj文件的目录
    ret 用于存放返回值的map, 如 { 'obj/main.o':'src/main.c' }
    '''
    ix = 1
    fn = os.path.splitext(os.path.split(src)[1])[0]
    while True:
        n = fn
        if ix != 1:
            n = n + str(ix)
        ix += 1
        n = os.path.join(obj_root, n + '.o')
        if not ret.has_key(n):
            ret[n] = src
            return n

def genmake(cfg):
    ret = ''

    includes = ' '.join(map(lambda x:'-I"'+x+'"', cfg.INCLUDE_PATHS))
    defines = ' '.join(map(lambda x: '-D '+x, cfg.DEFINES))

    ret += '#!/usr/bin/env make\n'
    ret += '# this file is auto-generated by genmake.py\n\n'
    ret += 'CC=' + cfg.CC + '\n'
    ret += 'LD=' + cfg.LD + '\n'
    ret += 'AR=' + cfg.AR + '\n'
    ret += 'CC_FLAGS=' + includes + ' ' + defines +  ' ' + cfg.CC_FLAGS + '\n\n'
    ret += 'OBJ_DIR=' + cfg.OBJ_DIR + '\n'
    ret += 'TARGET=' + cfg.TARGET + '\n\n'

    # 虚拟目标
    ret += 'all: $(TARGET)\n\n'
    ret += 'clean:\n' '\trm -rf $(OBJ_DIR)\n\trm -rf $(TARGET)\n\n'
    ret += 'rebuild: clean all\n\n'
    if cfg.TARGET_RUN and len(cfg.TARGET_RUN) > 0:
        ld_path = '$LD_LIBRARY_PATH'
        for e in cfg.LIB_DIRS:
            ld_path += ':' + os.path.abspath(e)
        run = os.path.abspath(cfg.TARGET_RUN)
        ret += 'run: $(TARGET)\n' '\t(cd "' + cfg.TARGET_RUN_DIR + '"; export LD_LIBRARY_PATH="' + ld_path + '"; "' + run + '" ' + cfg.TARGET_RUN_ARGS + ')\n\n'
        ret += 'gdb: $(TARGET)\n' '\t(cd "' + cfg.TARGET_RUN_DIR + '"; export LD_LIBRARY_PATH="' + ld_path + '"; gdb "' + run + '" ' + cfg.TARGET_RUN_ARGS + ')\n\n'
        ret += 'cgdb: $(TARGET)\n' '\t(cd "' + cfg.TARGET_RUN_DIR + '"; export LD_LIBRARY_PATH="' + ld_path + '"; cgdb "' + run + '" ' + cfg.TARGET_RUN_ARGS + ')\n\n'
        ret += 'nemiver: $(TARGET)\n' '\t(cd "' + cfg.TARGET_RUN_DIR + '"; export LD_LIBRARY_PATH="' + ld_path + '"; nemiver "' + run + '" ' + cfg.TARGET_RUN_ARGS + ')\n\n'
        ret += 'valgrind: $(TARGET)\n' '\t(cd "' + cfg.TARGET_RUN_DIR + '"; export LD_LIBRARY_PATH="' + ld_path + '"; valgrind -v --leak-check=full "' + run + '" ' + cfg.TARGET_RUN_ARGS + ')\n\n'

    # 所有的依赖关系
    all_srcs = []
    for e in cfg.SRC_DIRS:
        _get_allsrcs(e, all_srcs)
    obj_2_src = {}
    for e in all_srcs:
        p = os.popen(cfg.CC + ' -MM ' + includes + ' ' + cfg.CC_FLAGS + ' ' + e)
        dep = p.read()

        obj = _map_src_to_obj(e, cfg.OBJ_DIR, obj_2_src)
        try:
            dep = obj + dep[dep.index(':'): ]
        except ValueError: # 可能由于找不到头文件而导致取依赖出错
            print dep
            exit()

        ret += dep
        ret += '\t@mkdir -p ' + os.path.split(obj)[0] + '\n'
        ret += '\t$(CC) -c $(CC_FLAGS) $< -o $@\n\n'

    # 最终目标
    ret += '$(TARGET): ' + ' '.join(obj_2_src.keys()) + '\n'
    lib_include = ''
    for e in cfg.LIB_DIRS:
        lib_include += ' -L"' + e + '" '
    for e in cfg.LIBS:
        lib_include += ' -l' + e
    if cfg.TARGET.lower().endswith('.so'):
        ret += '\t$(LD) ' + lib_include + ' $^ -shared -o $@\n\n'
    elif cfg.TARGET.lower().endswith('.a'):
        ret += '\t$(AR) r $@ $^\n\n'
    else:
        ret += '\t$(CC) $(CC_FLAGS) ' + lib_include + ' $^ -o $@\n\n'

    return ret

